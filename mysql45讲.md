### 本笔记是极客时间丁奇的MySQL45讲笔记整理

# 01基础架构 一条SQL查询语句是如何执行的

![MySQL逻辑架构图](https://github.com/fikery/learnNotes/blob/master/source/0d2070e8f84c4801adbfa03bda1f98d9.png)

大体来说，MySQL可以分为server层和引擎层两部分。

# 02日志系统 一条SQL更新语句是如何执行的

# 03事务隔离 为什么你改了我还看不见

# 04深入浅出索引a

# 05深入浅出索引b

# 06全局锁和表锁 给表加个字段怎么有这么多障碍

根据加锁的范围，MySQL里面的锁可以分为：**全局锁，表级锁，行级锁**

**一、全局锁**

对整个数据库实例加锁

MySQL提供加全局读锁的方法：Flush tables with read lock(FTWRL)

整个命令使得整个库处于只读状态，使用该命令后，数据更新语句、数据定义语句和更新类事务提交语句等操作都会被阻塞。

使用场景：全库逻辑备份

风险：

1. 如果在主库备份，备份期间不能更新，业务停摆

2. 如果在从库备份，备份期间不能执行主库同步来的binlog，导致主从延迟

官方自带的逻辑备份工具mysqldump，当其使用参数-single-transaction的时候，会启动一个事务，确保拿到一致性视图(可重复读)，而由于MVCC(多版本并发控制)的支持，这个过程中数据是可以正常更新的。

可重复读(一致性读)虽好，但是前提是引擎要支持这个隔离级别，-single-transaction方法只适用于所有的表使用事务引擎的库，对于MyISAM这种不支持事务的引擎，备份过程中有更新，总是可以拿到最新的数据，就破坏了备份的一致性，此时就需要FTWRL命令了。

既然要全库只读，为什么不用set global readonly=true的方式呢？理由如下：

1. 在有些系统中，readonly的值会被用作其他逻辑，比如判断主备库，因此修改global变量的方式影响太大。

2. 异常处理机制上有差异。如果执行FTWRL命令后由于客户端断开，那么MySQL会自动释放这个全局锁，整个库回到可以正常更新状态；而设置readonly后，客户端异常，则数据库就会一直保持readonly状态，这会导致整个库处于不可写状态，风险较高。

3.  readonly对super权限无效。

**二、表级锁**

MySQL里面的表级锁有2种，一种是**表锁**，一种是**元数据锁**(meta data lock, MDL)

表锁的语法是：lock tables ... read/write。可以用unlock tables主动释放锁，也可以在客户端断开的时候自动释放。lock tables语法除了限制别的线程对表的读写，也限定了本线程接下来的操作，比如读锁不能写。对于InnoDB这种支持行锁的引擎，一般也不使用表锁来控制并发，毕竟影响还是太大。

MDL不需要显示使用，在访问表的时候自动加上，作用是保证读写的正确性。对一个表做增删改查操作的时候，加MDL读锁；对表结构做变更操作的时候，加MDL写锁。读锁之间不互斥，可以多个线程同时对一张表增删改查；读写锁之间、写锁之间互斥，如果多个线程同时要给一个表增加字段，需要依次执行。MDL直到事务提交才会释放，因此在做表结构变更的时候，一定要小心不要导致锁住线上查询与更新。
