### 本笔记是极客时间丁奇的MySQL45讲笔记整理

# 01基础架构 一条SQL查询语句是如何执行的

![MySQL逻辑架构图](https://github.com/fikery/learnNotes/blob/master/source/0d2070e8f84c4801adbfa03bda1f98d9.png)

大体来说，MySQL可以分为**Server层**和**引擎层**两部分。Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖大多数核心服务功能，及所有的内置函数，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。存储引擎层则负责数据的存储和提取，其架构是插件式的，支持InnoDB、MyISAM等多个存储引擎，现在常用，也是MySQL5.5版本开始的默认引擎InnoDB。

### 1.连接器

连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接器在跟服务端完成TCP握手后，就开始认证你的身份，如果用户名和密码通过认证，连接器就会到权限表中查询你拥有的权限，之后当前连接里所有权限判断都依赖此时读取的权限。这就意味着一个用户成功建立连接后，即使用管理员账号对此用户做了权限修改，也不会影响已经建立的连接权限，只有再建立新的连接，才会使用新的权限。

客户端如果长时间没动静，连接器就会自动断开，这个时间是参数wait_timeout控制的，默认值是8小时。建立连接的过程比较复杂，因此尽量使用长连接，但是长连接会导致MySQL内存占用涨的快，因为MySQL在执行过程中临时使用的内存是管理在连接对象里的，这些资源在连接断开时才释放。所以长连接累计可能导致内存占用过大，导致MySQL被系统强行杀掉(OOM)，现象就是MySQL异常重启了。

解决长连接资源占用问题，有2种方案可选：

1. 定期断开长连接，使用一段时间，或者程序中判断执行过一个大内存查询后，断开连接，然后重连。

2. 如果是MySQL5.7版本及以上，可以在每次执行一个大操作后，执行mysql_reset_connection来重置连接。这个过程无需重连和权限验证。

#### 2.查询缓存

MySQL拿到一个查询后，会先到查询缓存查看，之前有没有执行过这条语句，如果执行过其结果可能以k(语句)-v(结果)形式存在缓存中，此时如果查询命中缓存，则直接返回结果。但是大多数情况下不要使用查询缓存，因为往往弊大于利。查询缓存的失效非常频繁，只要有更新，表上的所有查询缓存都会被清空。所以除非业务就是个静态表，很久才更新，才适合使用查询缓存。MySQL8.0版本已经将查询缓存的整块功能删掉了。

#### 3.分析器

分析器开始真正执行语句，会做词法分析、语法分析等，分析器会判断语句是否正确，表是否存在，列是否存在等工作。

#### 4.优化器

优化器是在表里有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联(join)时，决定各个表的连接顺序，优化器会选择更高执行效率的方案。

#### 5.执行器

MySQL通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就到了执行器阶段，开始执行语句。开启执行的时候，先判断你对这个表是否有操作的权限，如果没有就返回权限错误(如果命中查询缓存，会在查询缓存返回结果的时候，做权限验证)，如果有权限，就打开表继续执行，打开表会调用相应的引擎。

执行器一般会调用引擎接口读取符合条件的“第一行”，判断是否存在结果集中，然后调用引擎接口取“下一行”，直到表的“最后一行”，然后执行器将结果集返回给客户端。数据库的慢查询日志有rows_examined的字段，表示这个语句执行过程中扫描了多少行，这个值是执行器每次调用引擎时累加的。但是在有些场景下，执行器调用一次，引擎却扫描了多行，因此引擎扫描行数和rows_examined并不是完全相同的。

# 02日志系统 一条SQL更新语句是如何执行的

# 03事务隔离 为什么你改了我还看不见

# 04深入浅出索引a

# 05深入浅出索引b

# 06全局锁和表锁 给表加个字段怎么有这么多障碍

根据加锁的范围，MySQL里面的锁可以分为：**全局锁，表级锁，行级锁**

**一、全局锁**

对整个数据库实例加锁

MySQL提供加全局读锁的方法：Flush tables with read lock(FTWRL)

整个命令使得整个库处于只读状态，使用该命令后，数据更新语句、数据定义语句和更新类事务提交语句等操作都会被阻塞。

使用场景：全库逻辑备份

风险：

1. 如果在主库备份，备份期间不能更新，业务停摆

2. 如果在从库备份，备份期间不能执行主库同步来的binlog，导致主从延迟

官方自带的逻辑备份工具mysqldump，当其使用参数-single-transaction的时候，会启动一个事务，确保拿到一致性视图(可重复读)，而由于MVCC(多版本并发控制)的支持，这个过程中数据是可以正常更新的。

可重复读(一致性读)虽好，但是前提是引擎要支持这个隔离级别，-single-transaction方法只适用于所有的表使用事务引擎的库，对于MyISAM这种不支持事务的引擎，备份过程中有更新，总是可以拿到最新的数据，就破坏了备份的一致性，此时就需要FTWRL命令了。

既然要全库只读，为什么不用set global readonly=true的方式呢？理由如下：

1. 在有些系统中，readonly的值会被用作其他逻辑，比如判断主备库，因此修改global变量的方式影响太大。

2. 异常处理机制上有差异。如果执行FTWRL命令后由于客户端断开，那么MySQL会自动释放这个全局锁，整个库回到可以正常更新状态；而设置readonly后，客户端异常，则数据库就会一直保持readonly状态，这会导致整个库处于不可写状态，风险较高。

3.  readonly对super权限无效。

**二、表级锁**

MySQL里面的表级锁有2种，一种是**表锁**，一种是**元数据锁**(meta data lock, MDL)

表锁的语法是：lock tables ... read/write。可以用unlock tables主动释放锁，也可以在客户端断开的时候自动释放。lock tables语法除了限制别的线程对表的读写，也限定了本线程接下来的操作，比如读锁不能写。对于InnoDB这种支持行锁的引擎，一般也不使用表锁来控制并发，毕竟影响还是太大。

MDL不需要显示使用，在访问表的时候自动加上，作用是保证读写的正确性。对一个表做增删改查操作的时候，加MDL读锁；对表结构做变更操作的时候，加MDL写锁。读锁之间不互斥，可以多个线程同时对一张表增删改查；读写锁之间、写锁之间互斥，如果多个线程同时要给一个表增加字段，需要依次执行。MDL直到事务提交才会释放，因此在做表结构变更的时候，一定要小心不要导致锁住线上查询与更新。
