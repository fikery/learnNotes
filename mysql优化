一些基本的查询优化操作：
1. 不要select *
2. 不要查询不需要的列
3. 不要多表联合返回全部的列
4. 不要重复查询，应当写入缓存
5. 尽量使用关联查询代替子查询
6. 使用索引优化
7. 查询优化，避免全表扫描，在where和order by的列上建立索引
8. 避免在where子句进行null值判断
9. 避免在where子句使用!=或<>操作符
10. 尽量不要使用前缀%，如like '%b'
11. 避免在where子句中进行表达式操作，如a+1=2
12. 避免在where子句中进行函数操作，如sum(a)=2
13. 使用exists代替in
14. 使用between代替in
15. where 语句里面如果带有or条件, myisam表能用到索引， innodb不行

索引的优点：
1. 减少扫描表的次数
2. 避免排序和临时表
3. 把随机IO变成顺序IO

高性能的索引策略：
1. 使用独立的列，而不是计算的列。如where a+1=2 / where a=1
2. 使用前缀索引原则
3. 多列索引，左序优先
4. 使用覆盖索引
5. 选择合适的索引顺序
6. 使用索引扫描来排序

不能使用索引的情况：
1. 查询使用了2种排序方向
2. order by中有一个无索引的列
3. where和order by无法形成最左前缀
4. 索引列的第一列是范围条件

建立索引的几个原则：
1. 最左前缀原则。mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
2. =可以乱序。比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。
3. 高区分度原则。尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。
4. 干净列原则。索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’)。
5. 优先拓展原则。尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。

慢查询优化步骤：
1. 找出高区分度的列
2. 让排序的表优先查，如order by limit 形式的sql语句
3. 了解业务方使用场景，根据业务修改查询字段
4. 加索引时参照建索引的几大原则
5. 观察结果，不行再来一遍
