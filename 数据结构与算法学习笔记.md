数据结构与算法，是编程的基础知识，同时也是编程能力进阶的核心知识点之一，因此有必要重学数据结构与算法，力求做到熟练使用，可以解决力扣中级难度题的程度

# 1.数组

**数组是一种线性表数据结构，用一组连续的内存空间，存储一组具有相同类型的数据**
* 线性表：数据排成线一样的结构，线性表上的数据只有前、后2个方向。线性表包括数组、链表、队列、栈
* 非线性表：数据间不是简单的前后关系，包括树、图、堆
* 连续的内存空间和相同类型的数据：这保证了数组的**随机访问**特性，但是也导致了**低效的插入和删除**，需要做大量的数据搬移
* 随机访问时间复杂度O(1),插入删除时间复杂度O(n)

计算机会给每个内存单元分配一个地址，通过地址来访问内存中的数据，对一个数组而言，申请一块连续的内存空间，首地址为base_address，计算机访问数组中的某个元素，就是通过数组首地址base_address、该元素的位置i、元素大小data_type_size，计算出该元素的内存地址address = base_address + i * data_type_size

*注意，数组的具有的O(1)时间复杂度特性的是随机访问，而不是查找*

# 2.链表
**链表与数组不同的是，并不需要一块连续的内存空间，而是通过指针将一组分散的内存块串联起来**
* 常见的链表有：单链表、双向链表、循环链表
* 链表除了包含数据外，还存储有指针，正是因为指针的存在，链表的头节点和尾节点比较特殊，访问元素从头节点开始，尾节点的next为null(单链表)
* 随机访问时间复杂度O(n),插入删除时间复杂度O(1)
* 循环链表是一种特殊的单链表，其尾节点指针指向头节点
* 双向链表较为常用，和单链表的结构区别在于支持2个方向，每个节点包含后继指针next和前驱指针prev。

双向链表所需存储空间比单链表大，但是在指定节点的条件下，插入删除都是O(1)时间复杂度，而单链表则需要从头查找是O(n)时间复杂度。另外对于一个有序链表，双向链表按值查询的效率也更高，因为可以存储上次查找的位置p，然后根据目标值与p的大小决定向前还是向后查找

```
1. 力扣第206题，反转链表

输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

普通解法：
class Solution:
    def reverseList(self, head):
        # 前指针节点
        pre = None
        # 当前指针节点
        cur = head
        # 每次循环，都将当前节点指向它前面的节点，然后前节点和当前节点后移
        while cur:
            # 临时节点，暂存当前节点的下一节点，用于后移
            node = cur.next
            # 将当前节点指向它前面的节点
            cur.next = pre
            # 前指针后移
            pre = cur
            # 当前指针后移
            cur = node
        return pre
        
神仙解法：
class Solution:
    def reverseList(self, head):
        """
        :head: ListNode
        :return: ListNode
        """
        p, rev = head, None
        while p:
            rev, rev.next, p = p, rev, p.next
        return rev
        
2. 力扣第141题，环形链表
给定一个链表，判断链表中是否有环。

class Solution:
    def hasCycle(self, head):
        # 定义慢指针，一次移动1个单位
        i=head
        # 定义快指针，一次移动2个单位
        i=head
        j=i
        while head:
            # 当快慢指针有一个后继节点为None时，说明不是循环链表
            if not i.next or not j.next or not j.next.next:
                return False
            i, j = i.next, j.next.next
            # 当快慢指针相遇时，说明是循环链表
            if i==j:
                return True
        return False

3. 力扣第21题，合并两个有序链表
将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

输入：1->2->4, 1->3->4
输出：1->1->2->3->4->4

class Solution:
    def mergeTwoLists(self, l1, l2):
        # 定义l1和l2的指针p1,p2
        p1, p2 = l1, l2
        # 定义一个头节点l3
        l3 = ListNode(None)
        # 定义l3的指针p3
        p3 = l3
        while p1 and p2:
            # 如果p1的值小于等于p2的值，则将p3的next指向p1节点；否则指向p2节点
            if p1.val <= p2.val:
                p3.next = p1
                p1 = p1.next
            else:
                p3.next = p2
                p2 = p2.next
            # p3指针后移
            p3 = p3.next
        # 如果l1和l2有一个未能遍历完成，则p3的next节点直接指向残留节点
        if not p1:
            p3.next = p2
        else:
            p3.next = p1
        return l3.next

4. 力扣第19题，删除链表的倒数第N个节点
给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。

给定一个链表: 1->2->3->4->5, 和 n = 2.
当删除了倒数第二个节点后，链表变为 1->2->3->5.

普通解法：
class Solution:
    def removeNthFromEnd(self, head, n):
        # 通过列表l将遍历的链表值存储，最后再移除目标值重新构建链表
        p, l = head, []
        node = ListNode(None)
        cur = node
        while p:
            l.append(p.val)
            p = p.next
        for idx, data in enumerate(l):
            if idx == len(l)-n:
                continue
            cur.next = ListNode(data)
            cur = cur.next
        return node.next

快慢指针解法：
class Solution:
    def removeNthFromEnd(self, head, n):
        a = head
        b = head
        # a指针作为快指针，先走n步
        for i in range(n):
            if a.next:
                a = a.next
            else:
                return head.next
        # 当快指针走到最后的时候，慢指针走到倒数第n个节点
        while a.next:
            a = a.next
            b = b.next
        b.next = b.next.next
        return head
        
5. 力扣第876题，链表中的中间节点
给定一个带有头结点 head 的非空单链表，返回链表的中间结点。
如果有两个中间结点，则返回第二个中间结点。

输入：[1,2,3,4,5]
输出：此列表中的结点 3 (序列化形式：[3,4,5])

class Solution:
    def middleNode(self, head):
        # 快慢指针的思想，p1每次移动一个单位，p2每次移动2个单位，当p2移动到最后的时候，p1位置是中间节点
        p1 = head
        p2 = head
        while p2 and p2.next:
            p1 = p1.next
            p2 = p2.next
            if p2:
                p2 = p2.next
            else:
                break
        return p1

```
# 3.栈
**栈是一种“操作受限”的线性表，只允许在一端进行插入和删除，FILO后进先出的数据结构**
* 栈既可以通过数组实现（顺序栈），也可以通过链表实现（链式栈）
* 栈操作包括入栈、出栈
* 空间复杂度和时间复杂度都是O(1)

**栈在函数调用中的应用**

操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构, 用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈

**栈在表达式求值中的应用**

编译器就是通过两个栈来实现的。其中一个保存操作数的栈，另一个是保存运算符的栈。我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；

当遇到运算符，就与运算符栈的栈顶元素进行比较。如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较

**栈在括号匹配中的应用**

我们假设表达式中只包含三种括号，圆括号 ()、方括号 [] 和花括号{}，并且它们可以任意嵌套。比如，{[{}]}或 [{()}([])] 等都为合法格式，而{[}()] 或 [({)] 为不合法的格式。那我现在给你一个包含三种括号的表达式字符串，如何检查它是否合法呢？

这里也可以用栈来解决。我们用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。如果能够匹配，比如“(”跟“)”匹配，“[”跟“]”匹配，“{”跟“}”匹配，则继续扫描剩下的字符串。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。

当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明有未匹配的左括号，为非法格式。

```
1. 力扣第20题，有效的括号
给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。
有效字符串需满足：
左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
注意空字符串可被认为是有效字符串。

输入: "()"
输出: true

普通解法：
class Solution:
    def isValid(self, s: str) -> bool:
        stack = []
        for i in s:
            if not stack:
                stack.append(i)
                continue
            if i ==')' and stack[-1] == '(' or i ==']' and stack[-1] == '[' or i =='}' and stack[-1] == '{':
                stack.pop()
            else:
                stack.append(i)
        return False if stack else True

大神解法：
class Solution:
    def isValid(self, s):
        while '{}' in s or '()' in s or '[]' in s:
            s = s.replace('{}', '')
            s = s.replace('[]', '')
            s = s.replace('()', '')
        return s == ''


2. 力扣第155题，
3. 力扣第232题，
4. 力扣第844题，
5. 力扣第224题，
6. 力扣第682题，
7. 力扣第496题，

```

# 4.队列

# 5.递归

# 6.排序

# 7.线性排序

# 8.排序优化

# 9.二分查找

# 10.跳跃表

# 11.哈希表

# 12.哈希算法

1. 哈希算法：将任意长度的二进制值串映射为固定长度的二进制值串，这个映射的规则就是哈希算法，映射得到的值就是哈希值。
2. 哈希算法4点要求：
* a.从哈希值不能反向推导出原始数据（所以哈希算法也叫单向哈希算法）
* b.对原始数据敏感，即使只修改了一个Bit，得到的哈希值也大不相同
* c.哈希冲突概率要小，不同的原始数据，哈希值相同的概率很小
* d.哈希算法效率要高，长文本也能快速计算哈希值
3. 常见的哈希算法：MD5(消息摘要算法)，SHA(安全哈希算法)，DES(数据加密标准)，AES(高级加密标准)等
4. 哈希算法的应用

### 1.安全加密 ###

采用的安全加密算法有MD5和SHA，对于一个哈希算法，我们能做的是尽量减少哈希碰撞的概率，因为哈希算法产生的哈希值长度是有限的，而要哈希的数据则是无限的，因此根据抽屉原理，必有冲突的情况。所以实际上，足够低的冲突概率可以满足加密要求，如MD5有128位，则对应2^128个不同的哈希值，即冲突概率小于1/2^128。越复杂的加密算法，需要的计算时间也越长，因此选择加密算法，需要衡量破解难度与计算时间。

### 2.唯一标识 ###

对于存储海量图片来说，通过哈希算法生成唯一图片名称是一个常见方式。比如可以从图片的二进制码串中，取开头100个字节，中间100个中间，最后100个字节，然后将这300个字节进行哈希操作，得到哈希值作为图片唯一标识。

### 3.数据校验 ###

比如通过迅雷下载文件，基于P2P协议的方式，会从多个机器上并行下载文件块，全部下载完成后再组装成完整的文件。

* 哈希函数
* 负载均衡
* 数据分片
* 分布式存储


# 13.二叉树

# 14.红黑树

# 15.递归树

# 16.堆

# 17.图

# 18.深度优先搜索

# 19.广度优先搜索

# 20.Trie树

# 21.AC自动机

# 22.贪心算法

# 23.分治算法

# 24.回溯算法

# 25.动态规划

# 26.拓扑排序

# 27.最短路径

# 28.B+树
