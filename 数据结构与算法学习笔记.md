数据结构与算法，是编程的基础知识，同时也是编程能力进阶的核心知识点之一，因此有必要重学数据结构与算法，力求做到熟练使用，可以解决力扣中级难度题的程度

# 1.数组

**数组是一种线性表数据结构，用一组连续的内存空间，存储一组具有相同类型的数据**
* 线性表：数据排成线一样的结构，线性表上的数据只有前、后2个方向。线性表包括数组、链表、队列、栈
* 非线性表：数据间不是简单的前后关系，包括树、图、堆
* 连续的内存空间和相同类型的数据：这保证了数组的**随机访问**特性，但是也导致了**低效的插入和删除**，需要做大量的数据搬移
* 随机访问时间复杂度O(1),插入删除时间复杂度O(n)

计算机会给每个内存单元分配一个地址，通过地址来访问内存中的数据，对一个数组而言，申请一块连续的内存空间，首地址为base_address，计算机访问数组中的某个元素，就是通过数组首地址base_address、该元素的位置i、元素大小data_type_size，计算出该元素的内存地址address = base_address + i * data_type_size

*注意，数组的具有的O(1)时间复杂度特性的是随机访问，而不是查找*

# 2.链表
**链表与数组不同的是，并不需要一块连续的内存空间，而是通过指针将一组分散的内存块串联起来**
* 常见的链表有：单链表、双向链表、循环链表
* 链表除了包含数据外，还存储有指针，正是因为指针的存在，链表的头节点和尾节点比较特殊，访问元素从头节点开始，尾节点的next为null(单链表)
* 随机访问时间复杂度O(n),插入删除时间复杂度O(1)
* 循环链表是一种特殊的单链表，其尾节点指针指向头节点
* 双向链表较为常用，和单链表的结构区别在于支持2个方向，每个节点包含后继指针next和前驱指针prev。

双向链表所需存储空间比单链表大，但是在指定节点的条件下，插入删除都是O(1)时间复杂度，而单链表则需要从头查找是O(n)时间复杂度。另外对于一个有序链表，双向链表按值查询的效率也更高，因为可以存储上次查找的位置p，然后根据目标值与p的大小决定向前还是向后查找

```
1. 力扣第206题，反转链表

输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

普通解法：
class Solution:
    def reverseList(self, head):
        # 前指针节点
        pre = None
        # 当前指针节点
        cur = head
        # 每次循环，都将当前节点指向它前面的节点，然后前节点和当前节点后移
        while cur:
            # 临时节点，暂存当前节点的下一节点，用于后移
            node = cur.next
            # 将当前节点指向它前面的节点
            cur.next = pre
            # 前指针后移
            pre = cur
            # 当前指针后移
            cur = node
        return pre
        
神仙解法：
class Solution:
    def reverseList(self, head):
        """
        :head: ListNode
        :return: ListNode
        """
        p, rev = head, None
        while p:
            rev, rev.next, p = p, rev, p.next
        return rev
        
2. 力扣第141题，环形链表
给定一个链表，判断链表中是否有环。

class Solution:
    def hasCycle(self, head):
        # 定义慢指针，一次移动1个单位
        i=head
        # 定义快指针，一次移动2个单位
        i=head
        j=i
        while head:
            # 当快慢指针有一个后继节点为None时，说明不是循环链表
            if not i.next or not j.next or not j.next.next:
                return False
            i, j = i.next, j.next.next
            # 当快慢指针相遇时，说明是循环链表
            if i==j:
                return True
        return False

3. 力扣第21题，合并两个有序链表
将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

输入：1->2->4, 1->3->4
输出：1->1->2->3->4->4

class Solution:
    def mergeTwoLists(self, l1, l2):
        # 定义l1和l2的指针p1,p2
        p1, p2 = l1, l2
        # 定义一个头节点l3
        l3 = ListNode(None)
        # 定义l3的指针p3
        p3 = l3
        while p1 and p2:
            # 如果p1的值小于等于p2的值，则将p3的next指向p1节点；否则指向p2节点
            if p1.val <= p2.val:
                p3.next = p1
                p1 = p1.next
            else:
                p3.next = p2
                p2 = p2.next
            # p3指针后移
            p3 = p3.next
        # 如果l1和l2有一个未能遍历完成，则p3的next节点直接指向残留节点
        if not p1:
            p3.next = p2
        else:
            p3.next = p1
        return l3.next

4. 力扣第19题，删除链表的倒数第N个节点
给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。

给定一个链表: 1->2->3->4->5, 和 n = 2.
当删除了倒数第二个节点后，链表变为 1->2->3->5.

普通解法：
class Solution:
    def removeNthFromEnd(self, head, n):
        # 通过列表l将遍历的链表值存储，最后再移除目标值重新构建链表
        p, l = head, []
        node = ListNode(None)
        cur = node
        while p:
            l.append(p.val)
            p = p.next
        for idx, data in enumerate(l):
            if idx == len(l)-n:
                continue
            cur.next = ListNode(data)
            cur = cur.next
        return node.next

快慢指针解法：
class Solution:
    def removeNthFromEnd(self, head, n):
        a = head
        b = head
        # a指针作为快指针，先走n步
        for i in range(n):
            if a.next:
                a = a.next
            else:
                return head.next
        # 当快指针走到最后的时候，慢指针走到倒数第n个节点
        while a.next:
            a = a.next
            b = b.next
        b.next = b.next.next
        return head
        
5. 力扣第876题，链表中的中间节点
给定一个带有头结点 head 的非空单链表，返回链表的中间结点。
如果有两个中间结点，则返回第二个中间结点。

输入：[1,2,3,4,5]
输出：此列表中的结点 3 (序列化形式：[3,4,5])

class Solution:
    def middleNode(self, head):
        # 快慢指针的思想，p1每次移动一个单位，p2每次移动2个单位，当p2移动到最后的时候，p1位置是中间节点
        p1 = head
        p2 = head
        while p2 and p2.next:
            p1 = p1.next
            p2 = p2.next
            if p2:
                p2 = p2.next
            else:
                break
        return p1

```
# 3.栈
**栈是一种“操作受限”的线性表，只允许在一端进行插入和删除，FILO后进先出的数据结构**
* 栈既可以通过数组实现（顺序栈），也可以通过链表实现（链式栈）
* 栈操作包括入栈、出栈
* 空间复杂度和时间复杂度都是O(1)

**栈在函数调用中的应用**

操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构, 用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈

**栈在表达式求值中的应用**

编译器就是通过两个栈来实现的。其中一个保存操作数的栈，另一个是保存运算符的栈。我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；

当遇到运算符，就与运算符栈的栈顶元素进行比较。如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较

**栈在括号匹配中的应用**

我们假设表达式中只包含三种括号，圆括号 ()、方括号 [] 和花括号{}，并且它们可以任意嵌套。比如，{[{}]}或 [{()}([])] 等都为合法格式，而{[}()] 或 [({)] 为不合法的格式。那我现在给你一个包含三种括号的表达式字符串，如何检查它是否合法呢？

这里也可以用栈来解决。我们用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。如果能够匹配，比如“(”跟“)”匹配，“[”跟“]”匹配，“{”跟“}”匹配，则继续扫描剩下的字符串。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。

当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明有未匹配的左括号，为非法格式。

```
1. 力扣第20题，有效的括号
给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。
有效字符串需满足：
左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
注意空字符串可被认为是有效字符串。

输入: "()"
输出: true

普通解法：
class Solution:
    def isValid(self, s: str) -> bool:
        stack = []
        for i in s:
            if not stack:
                stack.append(i)
                continue
            if i ==')' and stack[-1] == '(' or i ==']' and stack[-1] == '[' or i =='}' and stack[-1] == '{':
                stack.pop()
            else:
                stack.append(i)
        return False if stack else True

大神解法：
class Solution:
    def isValid(self, s):
        while '{}' in s or '()' in s or '[]' in s:
            s = s.replace('{}', '')
            s = s.replace('[]', '')
            s = s.replace('()', '')
        return s == ''


2. 力扣第155题，
3. 力扣第232题，
4. 力扣第844题，
5. 力扣第224题，
6. 力扣第682题，
7. 力扣第496题，

```

# 4.队列

# 5.递归

# 6.排序

# 7.线性排序

# 8.排序优化

# 9.二分查找

# 10.跳跃表

# 11.哈希表

# 12.哈希算法

问，**如何防止数据库中的用户信息被脱库？**

答：通过哈希算法，对用户密码进行哈希加密后存储。不过尽管如此，仍然可能通过字典攻击/彩虹表来撞库，此时我们可以通过加盐的方式，增加密码复杂度，拿salt+password的组合进行哈希加密，再存到数据库中，进一步增加破解的难度。或者通过计算哈希足够慢的算法如PBKDF2WithHmacSHA1，降低硬件计算速度，减少安全风险。

问，**哈希算法在分布式系统中有哪些应用？**

答：

### 1.哈希算法 ###

将任意长度的二进制值串映射为固定长度的二进制值串，这个映射的规则就是哈希算法，映射得到的值就是哈希值。

### 2.哈希算法4点要求 ###

* a 从哈希值不能反向推导出原始数据（所以哈希算法也叫单向哈希算法）
* b 对原始数据敏感，即使只修改了一个Bit，得到的哈希值也大不相同
* c 哈希冲突概率要小，不同的原始数据，哈希值相同的概率很小
* d 哈希算法效率要高，长文本也能快速计算哈希值

### 3.常见的哈希算法 ###

MD5(消息摘要算法)，SHA(安全哈希算法)，DES(数据加密标准)，AES(高级加密标准)等

### 4.哈希算法的应用 ###

#### (1)安全加密 ####

采用的安全加密算法有MD5和SHA，对于一个哈希算法，我们能做的是尽量减少哈希碰撞的概率，因为哈希算法产生的哈希值长度是有限的，而要哈希的数据则是无限的，因此根据抽屉原理，必有冲突的情况。所以实际上，足够低的冲突概率可以满足加密要求，如MD5有128位，则对应2^128个不同的哈希值，即冲突概率小于1/2^128。越复杂的加密算法，需要的计算时间也越长，因此选择加密算法，需要衡量破解难度与计算时间。

#### (2)唯一标识 ####

对于存储海量图片来说，通过哈希算法生成唯一图片名称是一个常见方式。比如可以从图片的二进制码串中，取开头100个字节，中间100个中间，最后100个字节，然后将这300个字节进行哈希操作，得到哈希值作为图片唯一标识。

#### (3)数据校验 ####

比如通过迅雷下载文件，基于P2P协议的方式，会从多个机器上并行下载文件块，全部下载完成后再组装成完整的文件。由于网络传输并不安全，下载的文件块可能被恶意修改过，因此需要校验文件块的安全、正确、完整。方法可以是，对100个文件块分别取哈希值，存在种子文件中，当全部下载完成，再通过相同的哈希算法对下载的文件逐一哈希，最后跟种子文件中保存的哈希值对比，进行数据校验。

#### (4)哈希函数 ####

哈希函数是设计一个哈希表的关键，它决定了哈希冲突的概率和哈希表的性能。不过相对于其他应用，哈希函数对冲突的要求要低很多，毕竟可以通过**开放寻址法**或者**链表法**等方式可以解决。另一方面，哈希函数对能否反向解密也不关心，更加关注的是哈希值能否均匀分布。因此哈希函数用的算法一般比较简单，追求效率。

#### (5)负载均衡 ####

负载均衡的算法有轮询、随机、加权轮询等，那**如何实现一个会话粘滞(session sticky)的负载均衡算法呢？**即在同一个客户端上，在一次会话中，所有请求都路由到同一个服务器上。

最简单的方法就是建立一个客户端IP与服务器编号的关系映射表，客户端发出请求先走映射表，查到服务器编号，再请求到服务器。简单的方法，有些弊端：
* 客户端很多时，映射表就很大，浪费内存空间
* 客户端上线/下线，服务器扩容/缩容，都会导致映射失效，维护映射表的成本很高

借助哈希算法，对客户端IP或者会话ID进行取哈希值，然后将哈希值与服务器列表的大小进行取模运算，得到的值就是应该被路由到的服务器编号。如此便可把同一个IP来的请求都路由到同一个服务器上。

#### (6)数据分片 ####

(1)**假如我们有1T的日志文件，里面记录了搜索关键词，需要快速统计出每个关键词被搜索的次数，该如何做？**

该问题有2个难度：
* 日志太大，无法在一台机器内存中处理
* 日志太大，处理时间会很长

借助哈希算法，可以先对数据进行分片，然后采用多台机器并行处理。假设用n台机器，从日志文件中，依次对关键词取哈希值，然后对n取模，得到的结果就是被分配的机器编号。这样哈希值相同的关键词就分配到了同一个机器上，每个机器分别计算关键词出现的次数，最后合并起来。这实际上也是MapReduce的基本设计思想。

(2)**如何快速判断图片是否在图库中？**

假如图库中有1亿张图片，采取哈希表的方式建立图片唯一标识与存储路径的关系，可能会超出单台机器的内存上限。同样采取分片的思想，准备n台机器，每台维护一部分哈希表。每次从图库中取一个图片计算唯一标识，然后与n取模，得到的值就是要分配的机器编号，最后将该图片的唯一标识与图片路径发往对应的服务器构建哈希表。当要判断图片是否存在时，同样的哈希取值，然后与n取模，得到机器编号k，最后去k的哈希表中查找。

**估算1亿张图片构建哈希表所需空间**

哈希表中每个数据单元包含2个信息，图片唯一标识(哈希值)与图片路径，假设通过MD5计算哈希值，长度为128比特，即16字节；文件路径最长256字节，取平均128字节；考虑可能存在哈希冲突，采用链表法则需要存储指针8字节，因此一个数据单元平均152字节。假设一台机器装填因子0.75，那么所需内存为1亿*152/0.75/1024/1024/1024=18GB。假设一台机器8GB内存，则至少需要3台机器。

#### (7)分布式存储 ####

面对海量的数据，为了提高数据的读写能力，一般采用分布式的方式存储数据，比如分布式缓存，而海量数据的分布式缓存通常需要多机部署。根据分片的思想，通过哈希算法对数据取哈希值，然后对机器取模，得到应该存储对机器编号。但是，如果数据增多，机器扩容，比如从10台扩容到11台，这就可能会出问题，比如12，原来对10取模，现在对11取模，结果不一样，那数据就分配错了，因此需要重新计算哈希值并且要转移数据到正确对机器上。这就相当于大量缓存突然失效，发送雪崩效应，压垮数据库。

所以我们需要一种方法，可以在加入一台机器后，并不需要做大量对数据转移，此时**一致性哈希算法**闪亮登场。比如表盘，现在有3台机器，分别是12点，4点，8点的位置，以顺时针的方向，数据1，2，3存到机器4中，5，7存在机器8中，9，10存在机器12中，现在要增加一台机器6，那么只需要把数据5转移到机器6中即可，其他的数据都不需要动。

# 13.二叉树

# 14.红黑树

# 15.递归树

# 16.堆

# 17.图

# 18.深度优先搜索

# 19.广度优先搜索

# 20.Trie树

# 21.AC自动机

# 22.贪心算法

# 23.分治算法

# 24.回溯算法

# 25.动态规划

# 26.拓扑排序

# 27.最短路径

# 28.B+树
