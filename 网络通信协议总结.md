# 1.UDP协议
传输层里有两个重要的协议，一个是TCP传输控制协议，一个是UDP用户数据报协议。

**TCP和UDP有哪些区别**

TCP是面向连接的，而UDP是面向无连接的。所谓的面向连接，就是在互通之前，面向连接的协议会先建立连接。比如TCP会三次握手，而UDP不会。
而所谓的建立连接，是为了在客户端和服务端维护连接，而建立一定的数据结构来维护双方的交互状态，用这样的数据结构来保证面向连接的特性。

例如TCP提供可靠交付，通过TCP连接传输的数据，无差错、不丢失、不重复、按序到达。IP包是没有任何可靠性保证的，一旦发出去就听天由命了，UDP就是继承了IP包的特性，不保证不丢失，也不保证按序到达。

另外TCP是面向字节流的，发送的时候是一个流，没头没尾。IP包则是一个个的包，UDP继承了IP的特性，基于数据报的，也是一个个的发，一个个的收。

TCP还是有拥塞控制的，当它意识到丢包了或者网络环境变差了，会根据情况调整自己的行为，看看是不是发的太快，要不要慢点。而UDP就不会，让我发，我就发，管他是不是包丢了网堵了。

TCP是有状态的服务，可以理解为有思想的，会精确的记录发送了没有，接收了没有，发送到哪个了，应该接收哪个了。而UDP则是无状态服务，不会记录这些信息。

打一个比方，如果说MAC层定义了本地局域网的传输行为，IP层定义了整个网络端到端的传输行为，这两层基本定义了如下规则：网络传输是以包为单位的，二层叫帧，网络层叫包，传输层叫段，笼统的都称为包。
包单独传输，自行选路，不保证到达。UDP完全继承了这些特性，几乎没有自己的特殊改造。

UPD包头，有源端口号，目标端口号，基本就没有其他的了，只剩下UDP长度和校验和这种数据。相比TCP头来说，简单的一塌糊涂。

UDP有以下特点：
* 结构简单。相信网络通路容易送达，不容易被丢弃。
* 没有连接。虽然有端口号，但是谁都可以给它传数据，它也可以给任何人传数据。
* 没有调控。不会根据网络情况进行发包的拥塞控制。

UDP的三大使用场景：
* 需要资源少，在网络情况好的内网，或者对丢包不敏感的应用。
* 不需要一对一建立连接沟通，而是可以广播的应用(DHCP动态主机配置协议)
* 需要快速处理，时延低，可容忍少量丢包，但要求不能自动降低发包频率的时候。

UPD几个应用举例：
* 网页或APP的访问。QUIC(快速UDP互联网连接)是谷歌推出的基于UDP改进的通信协议，目的是降低网络通信延迟。QUIC在应用层上会自己实现快速建立连接，减少重传时延，自适应拥塞控制。
* 流媒体协议。比如直播应用，在网络不好的时候，应该有选择的丢帧，因此很多都基于UDP实现了自己的视频传输协议。
* 实时游戏。争分夺秒的高实时性，采用UDP协议能够把丢包的延迟降到最低，减少网络问题对于游戏造成的影响。
* 移动通信领域。由于移动网络协议本身就很复杂，因此采用TCP就多余了。


# 2.TCP协议
就像人的成长一样，年轻的时候，认为这个世界是美好的，如同UDP认为网络世界是畅通的，没有丢包、乱序以及重传的。不过随着成长慢慢会发现，社会是残酷的，网络也是复杂的，这时候，UDP就成长为了TCP。

**TCP包头**

源端口，目标端口，包序号(解决乱序的问题)，确认序号(解决丢包的问题)，一些状态位(SYN是发起连接，ACK是回复，RST是重新连接，FIN是结束连接)，窗口大小(TCP要做流量控制和拥塞控制，双方各声明一个窗口标示自己当前的处理能力。)

TCP是靠谱的协议，但是不能保证它的网络环境好，从IP层面看，如果网络环境差，那么是无法保证可靠性的，作为上一层的TCP也无能为力。TCP能做的就是，你IP层丢不丢包我不管，我这一层要可靠。

**TCP的三次握手**

常称为"请求->应答->应答之应答"的三个回合。三次握手除了双方建立连接以外，还沟通了一件重要的事情，就是TCP包序号的问题。
之所以是三次握手，既不是二次也不是四次，主要是因为考虑到网络环境可能造成丢包、超时、重发等问题，两次不够，四次多余。

一开始，客户端和服务端都处于closed状态，
先是服务端主动监听某个端口，处于Listen状态，
然后客户端主动发起请求连接SYN，之后处于SYN-SENT状态。(第一握)
服务端收到发来的连接，返回SYN，并且ACK客户端的SYN，之后处于SYN-RCVD状态。(第二握)
客户端收到服务端发来的SYN和ACK之后，发送ACK的ACK，之后处于ESTABLISHED状态。(第三握)
服务端收到ACK的ACK之后，也处于ESTABLISHED状态(一发一收了)。

**TCP的四次挥手**

客户端请求断开，发送FIN，(第一次挥手)
服务端收到断开请求，发送ACK给客户端，进入close_wait状态，(第二次挥手)
客户端收到服务端的ACK，就进入FIN_WAIT_2的状态
服务端继续发送FIN和ACK给客户端，然后处于LAST_ACK状态，(第三次挥手)
客户端收到服务端的FIN，结束FIN_WAIT_2状态，发送ACK给服务端,(第四次挥手)
服务端收到最后的ACK，closed走人

TCP协议为了保证顺序性，每个包都有一个ID，在建立连接的时候，会商定起始的ID是什么，然后按照ID一个个发送。为了保证不丢包，对发送的包都要进行应答，但是这个应答不是一个个按顺序来的，而是应答之前的某个ID，这种模式称为累计确认或累计应答。

为了记录所有发送的包和接收的包，TCP需要发送端和接收端分别存有缓存来保存记录。发送端端缓存里按照包的ID一个个排列，根据处理情况分成四个部分：
* 发送了且已经确认的
* 发送了且尚未确认的
* 未发送，但是等待发送的
* 未发送，且暂时不发送的

对于接收端，它的缓存里有三部分：
* 接收且确认过的
* 还没接收，但是马上就能接收的
* 还没接收，暂时也没法接收的

对于顺序问题与丢包问题，一种方法是超时重试，但是本质上，顺序问题、丢包问题、流量控制都是通过滑动窗口来解决的。相当于布置的工作要有编号，完成的工作要有反馈，工作不能太多干不完，也不能太少没得干。
而拥塞控制是通过拥塞窗口来解决的，相当于往管道里倒水，快了容易溢出，慢了浪费带宽，比较好的一种方式是，带宽满而缓存不满，这样使得时延较低。


# 3.HTTP协议
HTTP协议属于应用层协议。其报文大概分为3部分，请求行，首部，实体。

第一部分，请求行：方法+url+版本。请求方法，主要有GET，POST，PUT，DELETE；版本选择多是1.1

第二部分，首部：字段名+字段值，是key-value形式。如Accept,Content-Type，Cache-Control，Connection,Cookie,Host,Refer,User-Agent等。
这里要重点说一下缓存，为什么要缓存呢？因为一个很大的页面会有很多东西。比如一个商品的详情页，会有价格、库存、图片、文字介绍等等。
商品的展示图片可能会长时间不变，而库存会经常变换。如果图片很大，库存数很小，那我们每次更新数据都要刷新整个页面，对服务器的压力就很大。
对于这种高并发下的系统，在真正的业务逻辑之前，要有一个接入层，将这些静态资源请求拦在外面。

Cache-Control用来控制缓存，当包含max-age指令时，如果判定缓存层中，资源缓存时间值比指定的时间值小，那么客户端就可以接受缓存资源；当指定max-age值为0，那么缓存层通常需要将请求转发给应用集群。

HTTP是基于TCP的，所以它使用面向连接的方式发送请求，但是HTTP本身是无连接、无状态的，因此一般浏览器会有cookie用于存储一些用户的状态使得浏览器可以识别用户，对于服务器而言会有一个session用来识别浏览器，因为cookie中存有一个sessionid。

**HTTP通过stream二进制流的方式传给对方，当然到了TCP层，它会把二进制流调整变成一个报文段发送给服务器(所以说TCP是面向字节流的协议，可以对数据流进行动态调整，也可以积累足够多的字节流构成报文段发出去)。在发送给每个报文段的时候，都需要对方有一个回应ACK，来保证报文可靠传达。如果对方没有回应，那么TCP层会重新传输，直到可以到达。同一个包可能被传了很多次，但是HTTP层是不知道的，都是TCP层干的事。**

**TCP层发送每一个报文的时候，都要加上自己的地址端口和目标端口，将这俩信息放到IP头里面，交给IP层传输。然后IP层会查看目标地址和自己是否在同一个局域网，如果是，就发送ARP协议来请求这个目标地址对应的MAC地址，然后将源MAC和目标MAC放入MAC头里面，发送出去；如果不在同一个局域网，就要发送到网关，还需要ARP协议来获取网关的MAC地址，然后将源MAC和网关MAC放入MAC头里，发送出去**

**网关收到包发现MAC符合，就取出IP地址，根据路由协议找到下一跳的路由器，获取其MAC地址，将包发给下一跳路由器。这样路由器一跳又一跳终于到了目标局域网，此时最后一跳的路由器发现，目标地址就在自己的某一个出口局域网上。于是在这个局域网上发送ARP，获取这个目标地址的MAC地址，将包发出去。**

**目标的机器发现MAC地址符合，就把包收下来；发现IP地址符合，就根据IP头中的各项协议，知道上一层是TCP协议，于是解析TCP的头，里面有序列号，这个时候需要看一下这个序列包是不是我要的，如果是就放入缓存中然后返回一个ACK，如果不是就丢弃**

**TCP头里有端口号，HTTP的服务器正在监听这个端口号，于是目标机器自然就知道是HTTP服务器进程想要这个包，于是将包发给HTTP服务器。HTTP的服务器进程看到这个请求是要访问某一个网页，于是就把网页发给客户端。**


HTTP返回，也是三部分：状态行+首部+实体。其中状态行包括版本、状态码、短语。状态码反映了HTTP的请求结果，200就是大吉大利，404就是找不到，500就是服务器挂了。然后短语大概说一下原因。

**构造好了返回HTTP报文，接下来就会把它发出去，还是交给Socket去发送，还是交给TCP层，让TCP层将返回的HTML分成一个个小的段，这些段加上TCP头后交给IP层，然后把刚才请求报文的流程反向走一波，虽然两次不一定走相同的路径，但是逻辑过程是一样的，直到到达客户端。**

**客户端发现MAC地址符合、IP地址符合，于是就交给TCP层，根据序列号看看是不是自己要的报文段，如果是则会根据TCP头中的端口号，发给相应的进程。这个进程就是浏览器，浏览器也是在监听某个端口的**

**当浏览器拿到了HTTP的报文，发现状态码是200，就从正文中把HTML拿出来，HTML是一个标准的网页格式，浏览器根据这个格式就可以展示出一个bling~bling的网页。**

以上就是一个正常的HTTP请求和响应的完整过程。


**由于HTTP1.1在应用层以纯文本的形式进行通信，每次通信都要带着完整的HTTP头，如果不考虑pipeline模式的话，每次的过程都是像上面那样一去一回，这样在实时性、并发性上都有问题。**

**于是就有了HTTP2.0，通过头压缩、分帧、二进制编码、多路复用等技术提升性能。HTTP2.0虽然大大增加了并发性，但是还有问题，因为仍然基于TCP协议，处理包时有严格的顺序，当有一个包遇到问题，TCP需要等这个包完成重传后才能继续传输。因此到了TCP切换到UDP的时候，这就是谷歌的QUIC协议。**

**QUIC协议通过基于UDP自定义类似TCP的连接、重试、多路复用、流量控制等技术，进一步提升性能。**


# 4.HTTPS协议
对称加密算法中，加密和解密使用的密钥是相同的，因此要做好密钥的保密，不能对外公开。
非对称加密算法中，加密和解密使用的密钥是不同的，一把公开的公钥，一把保密的私钥，公钥加密的信息只有私钥才能解密；私钥加密的信息只有公钥才能解密。
非对称加密需要通过证书和权威机构来验证公钥的合法性。
对称加密算法相比非对称加密算法，效率高性能好，所以交互场景下多用对称加密。

HTTPS协议采用的是非对称加密和对称加密相结合的方式进行通信。
非对称加密方式加密一个对称秘钥，然后通信内容通过对称秘钥进行加密通信。

1. 客户端发送HTTPS加密通信请求(你好，我要访问HTTPS网站，我的加密套路是这样的，给你一个随机数a，后面有用)
2. 服务端响应请求(好的，我这边的加密套路是这样的，也给你个随机数b)
3. 服务端发送证书(这是我的证书，你审核一下看看)
4. 服务端发送完成(好了，我这边信息发完了Done)
5. 客户端进行证书校验，取出公钥，产生随机数c，然后将随机数采用公钥加密传输
6. 客户端与服务端，分别通过a+b+c算出对称秘钥
7. 客户端发送对称加密通知(用户就用对称秘钥传输啦)
8. 客户端发送握手验证(先把之前咱们商量的参数加密传输试一下)
9. 服务端发送对称加密通知(好的，以后就用对称秘钥传输数据)
10. 服务端发送握手验证(先把之前咱们商量的参数加密传输试一下)
11. 双方开启加密通信









