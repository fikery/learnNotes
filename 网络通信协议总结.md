# 1.UDP协议
传输层里有两个重要的协议，一个是TCP传输控制协议，一个是UDP用户数据报协议。

**TCP和UDP有哪些区别**

TCP是面向连接的，而UDP是面向无连接的。所谓的面向连接，就是在互通之前，面向连接的协议会先建立连接。比如TCP会三次握手，而UDP不会。
而所谓的建立连接，是为了在客户端和服务端维护连接，而建立一定的数据结构来维护双方的交互状态，用这样的数据结构来保证面向连接的特性。

例如TCP提供可靠交付，通过TCP连接传输的数据，无差错、不丢失、不重复、按序到达。IP包是没有任何可靠性保证的，一旦发出去就听天由命了，UDP就是继承了IP包的特性，不保证不丢失，也不保证按序到达。

另外TCP是面向字节流的，发送的时候是一个流，没头没尾。IP包则是一个个的包，UDP继承了IP的特性，基于数据报的，也是一个个的发，一个个的收。

TCP还是有拥塞控制的，当它意识到丢包了或者网络环境变差了，会根据情况调整自己的行为，看看是不是发的太快，要不要慢点。而UDP就不会，让我发，我就发，管他是不是包丢了网堵了。

TCP是有状态的服务，可以理解为有思想的，会精确的记录发送了没有，接收了没有，发送到哪个了，应该接收哪个了。而UDP则是无状态服务，不会记录这些信息。

打一个比方，如果说MAC层定义了本地局域网的传输行为，IP层定义了整个网络端到端的传输行为，这两层基本定义了如下规则：网络传输是以包为单位的，二层叫帧，网络层叫包，传输层叫段，笼统的都称为包。
包单独传输，自行选路，不保证到达。UDP完全继承了这些特性，几乎没有自己的特殊改造。

UPD包头，有源端口号，目标端口号，基本就没有其他的了，只剩下UDP长度和校验和这种数据。相比TCP头来说，简单的一塌糊涂。

UDP有以下特点：
* 结构简单。相信网络通路容易送达，不容易被丢弃。
* 没有连接。虽然有端口号，但是谁都可以给它传数据，它也可以给任何人传数据。
* 没有调控。不会根据网络情况进行发包的拥塞控制。

UDP的三大使用场景：
* 需要资源少，在网络情况好的内网，或者对丢包不敏感的应用。
* 不需要一对一建立连接沟通，而是可以广播的应用(DHCP动态主机配置协议)
* 需要快速处理，时延低，可容忍少量丢包，但要求不能自动降低发包频率的时候。

UPD几个应用举例：
* 网页或APP的访问。QUIC(快速UDP互联网连接)是谷歌推出的基于UDP改进的通信协议，目的是降低网络通信延迟。QUIC在应用层上会自己实现快速建立连接，减少重传时延，自适应拥塞控制。
* 流媒体协议。比如直播应用，在网络不好的时候，应该有选择的丢帧，因此很多都基于UDP实现了自己的视频传输协议。
* 实时游戏。争分夺秒的高实时性，采用UDP协议能够把丢包的延迟降到最低，减少网络问题对于游戏造成的影响。
* 移动通信领域。由于移动网络协议本身就很复杂，因此采用TCP就多余了。


# 2.TCP协议
就像人的成长一样，年轻的时候，认为这个世界是美好的，如同UDP认为网络世界是畅通的，没有丢包、乱序以及重传的。不过随着成长慢慢会发现，社会是残酷的，网络也是复杂的，这时候，UDP就成长为了TCP。

**TCP包头**

源端口，目标端口，包序号(解决乱序的问题)，确认序号(解决丢包的问题)，一些状态位(SYN是发起连接，ACK是回复，RST是重新连接，FIN是结束连接)，窗口大小(TCP要做流量控制和拥塞控制，双方各声明一个窗口标示自己当前的处理能力。)

TCP是靠谱的协议，但是不能保证它的网络环境好，从IP层面看，如果网络环境差，那么是无法保证可靠性的，作为上一层的TCP也无能为力。TCP能做的就是，你IP层丢不丢包我不管，我这一层要可靠。

**TCP的三次握手**

常称为"请求->应答->应答之应答"的三个回合。三次握手除了双方建立连接以外，还沟通了一件重要的事情，就是TCP包序号的问题。
之所以是三次握手，既不是二次也不是四次，主要是因为考虑到网络环境可能造成丢包、超时、重发等问题，两次不够，四次多余。

一开始，客户端和服务端都处于closed状态，
先是服务端主动监听某个端口，处于Listen状态，
然后客户端主动发起请求连接SYN，之后处于SYN-SENT状态。(第一握)
服务端收到发来的连接，返回SYN，并且ACK客户端的SYN，之后处于SYN-RCVD状态。(第二握)
客户端收到服务端发来的SYN和ACK之后，发送ACK的ACK，之后处于ESTABLISHED状态。(第三握)
服务端收到ACK的ACK之后，也处于ESTABLISHED状态(一发一收了)。

**TCP的四次挥手**

客户端请求断开，发送FIN，(第一次挥手)
服务端收到断开请求，发送ACK给客户端，进入close_wait状态，(第二次挥手)
客户端收到服务端的ACK，就进入FIN_WAIT_2的状态
服务端继续发送FIN和ACK给客户端，然后处于LAST_ACK状态，(第三次挥手)
客户端收到服务端的FIN，结束FIN_WAIT_2状态，发送ACK给服务端,(第四次挥手)
服务端收到最后的ACK，closed走人

TCP协议为了保证顺序性，每个包都有一个ID，在建立连接的时候，会商定起始的ID是什么，然后按照ID一个个发送。为了保证不丢包，对发送的包都要进行应答，但是这个应答不是一个个按顺序来的，而是应答之前的某个ID，这种模式称为累计确认或累计应答。

为了记录所有发送的包和接收的包，TCP需要发送端和接收端分别存有缓存来保存记录。发送端端缓存里按照包的ID一个个排列，根据处理情况分成四个部分：
* 发送了且已经确认的
* 发送了且尚未确认的
* 未发送，但是等待发送的
* 未发送，且暂时不发送的

对于接收端，它的缓存里有三部分：
* 接收且确认过的
* 还没接收，但是马上就能接收的
* 还没接收，暂时也没法接收的

对于顺序问题与丢包问题，一种方法是超时重试，但是本质上，顺序问题、丢包问题、流量控制都是通过滑动窗口来解决的。相当于布置的工作要有编号，完成的工作要有反馈，工作不能太多干不完，也不能太少没得干。
而拥塞控制是通过拥塞窗口来解决的，相当于往管道里倒水，快了容易溢出，慢了浪费带宽，比较好的一种方式是，带宽满而缓存不满，这样使得时延较低。










